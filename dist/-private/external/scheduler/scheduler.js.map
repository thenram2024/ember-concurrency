{"version":3,"file":"scheduler.js","sources":["../../../../src/-private/external/scheduler/scheduler.js"],"sourcesContent":["import SchedulerRefresh from './refresh';\nimport StateTracker from './state-tracker/state-tracker';\nimport NullStateTracker from './state-tracker/null-state-tracker';\n\n// Scheduler base class\n\n// When a Task is performed, it creates an unstarted TaskInstance and\n// passes it to the Scheduler to determine when it should run. The\n// scheduler consults the schedulerPolicy (e.g. DropPolicy, RestartablePolicy, etc)\n// to determine whether the task instance should start executing, be enqueued\n// for later execution, or be immediately cancelled. As TaskInstances start\n// and run to completion, the Scheduler's `refresh()` method is called to\n// give it an opportunity to start (or cancel) previously enqueued task instances,\n// as well as update the derived state on Tasks and TaskGroups.\n\n// Every Task has its own Scheduler instance, unless it is part of a group,\n// in which case all the Tasks in a group share a single Scheduler.\n\nclass Scheduler {\n  constructor(schedulerPolicy, stateTrackingEnabled) {\n    this.schedulerPolicy = schedulerPolicy;\n    this.stateTrackingEnabled = stateTrackingEnabled;\n    this.taskInstances = [];\n  }\n\n  cancelAll(guid, cancelRequest) {\n    let cancelations = this.taskInstances\n      .map((taskInstance) => {\n        if (taskInstance.task.guids[guid]) {\n          taskInstance.executor.cancel(cancelRequest);\n        }\n      })\n      .filter((cancelation) => !!cancelation);\n\n    return Promise.all(cancelations);\n  }\n\n  perform(taskInstance) {\n    taskInstance.onFinalize(() => this.scheduleRefresh());\n    this.taskInstances.push(taskInstance);\n    this.refresh();\n  }\n\n  scheduleRefresh() {\n    Promise.resolve().then(() => this.refresh());\n  }\n\n  refresh() {\n    let stateTracker = this.stateTrackingEnabled\n      ? new StateTracker()\n      : new NullStateTracker();\n    let refresh = new SchedulerRefresh(\n      this.schedulerPolicy,\n      stateTracker,\n      this.taskInstances,\n    );\n    this.taskInstances = refresh.process();\n  }\n}\n\nexport default Scheduler;\n"],"names":["Scheduler","constructor","schedulerPolicy","stateTrackingEnabled","taskInstances","cancelAll","guid","cancelRequest","cancelations","map","taskInstance","task","guids","executor","cancel","filter","cancelation","Promise","all","perform","onFinalize","scheduleRefresh","push","refresh","resolve","then","stateTracker","StateTracker","NullStateTracker","SchedulerRefresh","process"],"mappings":";;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAMA,SAAS,CAAC;AACdC,EAAAA,WAAWA,CAACC,eAAe,EAAEC,oBAAoB,EAAE;IACjD,IAAI,CAACD,eAAe,GAAGA,eAAe,CAAA;IACtC,IAAI,CAACC,oBAAoB,GAAGA,oBAAoB,CAAA;IAChD,IAAI,CAACC,aAAa,GAAG,EAAE,CAAA;AACzB,GAAA;AAEAC,EAAAA,SAASA,CAACC,IAAI,EAAEC,aAAa,EAAE;IAC7B,IAAIC,YAAY,GAAG,IAAI,CAACJ,aAAa,CAClCK,GAAG,CAAEC,YAAY,IAAK;MACrB,IAAIA,YAAY,CAACC,IAAI,CAACC,KAAK,CAACN,IAAI,CAAC,EAAE;AACjCI,QAAAA,YAAY,CAACG,QAAQ,CAACC,MAAM,CAACP,aAAa,CAAC,CAAA;AAC7C,OAAA;KACD,CAAC,CACDQ,MAAM,CAAEC,WAAW,IAAK,CAAC,CAACA,WAAW,CAAC,CAAA;AAEzC,IAAA,OAAOC,OAAO,CAACC,GAAG,CAACV,YAAY,CAAC,CAAA;AAClC,GAAA;EAEAW,OAAOA,CAACT,YAAY,EAAE;IACpBA,YAAY,CAACU,UAAU,CAAC,MAAM,IAAI,CAACC,eAAe,EAAE,CAAC,CAAA;AACrD,IAAA,IAAI,CAACjB,aAAa,CAACkB,IAAI,CAACZ,YAAY,CAAC,CAAA;IACrC,IAAI,CAACa,OAAO,EAAE,CAAA;AAChB,GAAA;AAEAF,EAAAA,eAAeA,GAAG;AAChBJ,IAAAA,OAAO,CAACO,OAAO,EAAE,CAACC,IAAI,CAAC,MAAM,IAAI,CAACF,OAAO,EAAE,CAAC,CAAA;AAC9C,GAAA;AAEAA,EAAAA,OAAOA,GAAG;AACR,IAAA,IAAIG,YAAY,GAAG,IAAI,CAACvB,oBAAoB,GACxC,IAAIwB,YAAY,EAAE,GAClB,IAAIC,gBAAgB,EAAE,CAAA;AAC1B,IAAA,IAAIL,OAAO,GAAG,IAAIM,OAAgB,CAChC,IAAI,CAAC3B,eAAe,EACpBwB,YAAY,EACZ,IAAI,CAACtB,aACP,CAAC,CAAA;AACD,IAAA,IAAI,CAACA,aAAa,GAAGmB,OAAO,CAACO,OAAO,EAAE,CAAA;AACxC,GAAA;AACF;;;;"}